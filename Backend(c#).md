Основные вопросы по backend части приложений, в частности c#

# C#

## Базовые конструкции

### Переменные

Статья: https://metanit.com/sharp/tutorial/2.25.php
В программировании в целом **переменные** нужны для хранения временных данных. Она представляет собой область данных в памяти, в которой хранится значение определенного типа. 
Переменная имеет 3 параметра: 

* Тип (string, bool, float, int, char...)
* Имя (должно быть одной строкой без пробелов, чувствительно к регистру)
* Значение

Как задать переменную: 

```c#
//тип_данных название
string name;

//присвоение значения
name = "test";
```

Все типы данных, которые есть в c#, тут https://metanit.com/sharp/tutorial/2.1.php

Если не присваивать переменной значение, то она примет значение default, уникальное для своего типа

```c#
object obj; //будет null
int num; //будет 0
string str; //будет null
bool boo; //будет false
```

### Преобразования типов данных
Статья: https://metanit.com/sharp/tutorial/2.2.php

```c#
//можно конвертить базовые типы явно
int test = 5;
long newTest = (long)test;

//но лучше это делать через Convert
string test = "5";
int newTest = Convert.ToInt32(test);


```

### Условия

Статья: https://metanit.com/sharp/tutorial/2.24.php, https://metanit.com/sharp/tutorial/2.5.php

Работают на основе bool, в языке используются конструкции: if..else и switch..case

```c#
//можно сначала расчитать переменную, потом передать ее в if, либо сразу написать условие
bool condit = 5 > 2;

if(condit) {
    //если true
}
else {
   	//если false
}
//альтернатива
if(5 > 2) {
    //если true
}
else {
   	//если false
}
```

Если надо много условий, то варианта 2: либо логические операции, либо else if

```c#
int a = 5;
//если условия можно проверить последовательно
if(a > 0) {
    
}
else if(a > 3) {
    
}
//сколько угодно раз

//если условия надо проверить одновременно
//&& -> true && false = false (логическое умножение)
//|| -> true || false = true (логическое сложение)
if(a>0&& a < 5 || a > 100) {
    //если true
}
else {
    //если false
}
```

### Циклы

Статья: https://metanit.com/sharp/tutorial/2.6.php
Виды циклов и их разница: 

```c#
//если надо посчитать определенное количество раз и ты точно знаешь сколько:
//три параметра: начальное значение, условие работы, как счетчик будет изменяться
//тут цикл будет идти от 0 до 8, увеличиваясь каждый раз
for (int i = 0; i < 9; i++)
{
    Console.WriteLine($"Квадрат числа {i} равен {i*i}");
}

//если ты не знаешь точно, сколько итераций тебе надо:
//while и do while будут работать, пока верно условие в скобках while
//разница лишь в том, что do while всегда сделает первую итерацию, обычный while этого делать не должен
int i = 6;
do
{
    Console.WriteLine(i);
    i--;
}
while (i > 0);
//
int i = 6;
while (i > 0)
{
    Console.WriteLine(i);
    i--;
}

//если надо перебрать коллекцию(массив), то foreach
var mass = new List<int>();
foreach(var elem in mass) {
    //elem это каждый элемент массива по очереди
}
```

Есть ключевые слова, которые могут остановить цикл или пропустить одну итерацию

```c#
var mass = new List<int>();
foreach(var elem in mass) {
    continue; // пропустит итерацию в цикле, продолжит работать со следующей
    break; //остановит цикл впринципе
}
```

### Массивы и коллекции

Статьи: https://metanit.com/sharp/tutorial/2.4.php, https://metanit.com/sharp/tutorial/4.3.php

Массив представляет набор однотипных данных. Есть несколько видов коллекций, которые различаются по алгоритму взаимодействия с данными. Самых ходовых две: 

```c#
//Обычный массив
//имеет ограниченное количество элементов
int[] array = new int[5] {1,2,3,4,5};
//получение элемента
int elem = array[0];

//Динамический список, может расширять количество элементов при помощи нескольких методов
List<int> array = new List<int>() {1,2,3,4,5};
//получение элемента такое же
int elem = array[0];
//добавить элемент в коллекцию
array.Add(6);
//удалить элемент из коллекции
array.Remove(1);
```

### Перечисления enum

Статья: https://metanit.com/sharp/tutorial/2.12.php

Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора **enum**. Если значения для констант не указывать, то расчет начнется с 0

```c#
enum Operation
{ 
    Add = 1,   // каждый следующий элемент по умолчанию увеличивается на единицу
    Subtract, // этот элемент равен 2
    Multiply, // равен 3
    Divide    // равен 4
}

//переменная типа Enum
Operation test = Operation.Add;
```

### Обработка ошибок 

Статья: https://metanit.com/sharp/tutorial/2.14.php

Обработка ошибок позволяет нам ловить ошибки и не ронять приложение.

Пишется в тот момент, когда ты не уверен в коде, или ожидаешь ошибку в уникальной ситуации

```c#
var array = new int[] {1,2,3};

try{
    var element = array[10]; //IndexOutOfRange ошибкаб приложение бы упало
    //но изза try приложение поймает ошибку и продолжит в catch
}
catch(Exception e) {
    //код продолжится тут
}
finally {
    //этот блок выполнится в любом случае, независимо от наличия ошибки
}
```



## Классы и немного ООП

### Что такое классы и их объекты

Статья: https://metanit.com/sharp/tutorial/3.1.php (и дальше по главе)

В c# принято представлять программу в виде взаимодействия объектов между собой

Описанием объекта является **класс**, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. То есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.

```c#
// создание класса
public class MyClass {
    //...
}
//создание объекта класса
MyClass obj = new MyClass();
```

Через объект класса мы можем взаимодействовать с его **состоянием** и **поведением**

### Ссылочные типы и типы значений

Статья: https://metanit.com/sharp/tutorial/2.16.php

В языке есть 2 типа данных ( и один особенный )

* Типы значений ( структуры, int, bool, double, float..., **не объекты классов и не string!!!**)
* Типы ссылок (объекты классов, string)
* Immutable Reference Type (string, record) - можно не называть на интервью на джуна

Разница этих типов заключается в поведении и в месте хранения в памяти

Есть два места в .Net, где хранятся переменные

* Стек (https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA) - тут хранятся типы значений и  ссылки на типы ссылок
* Куча (Heap https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)) - тут хранятся объекты ссылочных типов, доступ к этой памяти осуществляется через ссылки в стеке

Пример

```c#
//типы значений
int a = 5; //останется 5
int b = a; // тут создастся новая переменная
b = 6; //a и b это две разные переменные, и значения у них копируются!!!

//типы ссылок
Person person = new Person(); //новая ссылка, новый объект
person.Name = "test"; // изменится person

Person newPerson = person; //ссылка на один и тот же объект!!!

newPerson.Name = "123"; // изменится и person, и newPerson
// так как у них ссылка на один и тот же объект


//immutable reference type
string str = "newStr"; //новый объект в куче, новая ссылка

string newStr = str; 

newStr = "123"; //изменится только newStr, str останется такой же
//хранится как ссылочный, но ведет себя как тип значений

```

### Описание класса 

Класс создается ключевым словом **class** и может содержать в себе 4 характеристиками : поля и свойства (**состояние**), конструкторы и методы (**поведение**).

**Поля** - просто переменные, содержащие состояние объекта класса

```c#
public class MyClass {
    public int field; //поле класса MyClass
}
```

**Свойства** - те же поля, но имеют правила доступа к данным (аксессоры)

```c#
public class MyClass {
    public int Field {get; set} //свойство класса MyClass
}
```

**Методы** - это выделенные блоки кода, которые выполняют определенные действия. Методы описывают **поведение** класса. В возвращаемом значении указывается либо void (если ничего не нужно возвращать из метода, **return** не обязателен), либо тип данных, который должен вернуться по завершению метода(**return** обязателен)

```c#
public class MyClass {
    public void Print() { //метод класса MyClass, который ничего не возвращает
        Console.WriteLine("test");
    } 
    public int Print() { //метод класса MyClass, который должен вернуть число
        Console.WriteLine("test");
        return 0;
    } 
}
```

**Конструкторы** - методы, которые используются для создания объекта, называются так же как класс и **не имеют** возвращаемого значения. Вызываются ключевым словом **new**

```c#
public class MyClass {
    //конструктор по умолчанию класса MyClass
    public MyClass() {
        
    } 
    //обычный конструктор класса MyClass
    public MyClass(int a) {
        
    } 
}

MyClass obj = new MyClass(); //сработает конструктор по умолчанию
MyClass obj1 = new MyClass(5); //сработает обычный конструктор 
```

### Модификаторы доступа 

Статья: https://metanit.com/sharp/tutorial/3.2.php

В C# применяются следующие модификаторы доступа:

Основные: 

* **public**: публичный, видно везде. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
* **private**: приватный, видно только внутри класса или контекста. Представляет полную противоположность модификатору public. 
* **protected**:  видно только внутри самого класса, и его дочерних классах. При этом производные классы могут располагаться в других сборках.
* **internal**: почти как public, но видно только в текущей программе(сборке)

Дополнительные: 

* **protected internal**: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
* **private protected**: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.

### Наследование

Статья: https://metanit.com/sharp/tutorial/3.7.php

Наследование нужно, чтобы передать функционал базового класса дочернему. Передадутся все свойства и методы, которые помечены модификатором **protected** и **public** 

```c#
public class Person {
    private bool foo; // не перейдет в дочерний
    public int Field {get; set;} // перейдет в дочерний
    protected void Method() { // перейдет в дочерний
        
    }
}
public class Employee : Person {
    //будет содержать свойство Field и метод Method
}

// при использовании объекта можно создавать объекты так:
Person obj = new Employee();
```

Про ковариантность можно почитать тут: https://metanit.com/sharp/tutorial/3.27.php

### Абстрактные, статические  классы и виртуальные методы

У классов и методов могут быть модификаторы, такие как **abstract** и **static**
Оба типа классов не могут иметь объектов, но взаимодействие с их содержимым различается. Абстрактные классы требуют наследования, и взаимодействовать с ними возможно только через объект дочернего класса

```c#
public abstract class BasicClass {
    public void Test() {
		//...        
    }
}
public class ChildClass : BasicClass {
    
}

ChildClass obj = new ChildClass();
obj.Test(); //вызов метода абстрактного класса

BasicClass obj1 = new BasicClass(); // нельзя!
```

Методы статического класса можно вызвать только от самого класса, не вызывая его объекта

```c#
public static class BasicClass {
    public static void Test() {
		//...        
    }
}
BasicClass obj1 = new BasicClass(); // нельзя!
BasicClass.Test(); //вызов статического метода
```

Так же абстрактные и виртуальные методы можно переопределить при помощи ключевого слова **override**. Отличие абстрактного лишь в том, что он требует переопределение, а виртуальный лишь предоставляет возможность

```c#
public abstract class BasicClass {
    public abstract void Test() {
		//...        
    }
    public virtual void Meth() {
        
    }
}
public class ChildClass : BasicClass {
    public override void Test() { //обязательно
		//...        
    }
    public override void Meth() { // при неоходимости
        
    }
}
```

### Интерфейсы

Статья: https://metanit.com/sharp/tutorial/3.9.php

Интерфейсы используются для определения поведения класса без его конечной реализации и требуют от класса выполнения созданных ограничений. Пишется как обычное наследование

```c#
public interface IInter {
    void Test();
}

public class ChildInter : IInter {
    public void Test() { //обязательно
        
    }
}

// при использовании интерфейса можно делать вот так:
IInter obj = new ChildInter();
//Объект интерфейса нельзя создать:
IInter obj = new IInter(); //не будет работать
```

### IDisposable ( конструкция using)

Статья: https://metanit.com/sharp/tutorial/8.2.php

В .net есть два вида ресурсов, которыми платформа оперирует: 

* Управляемые - все что .net может сам контролировать (простые переменные, простые объекты классов и тд)
* Неуправляемые - все, с чем .net не может сам разобраться ( подключения к бд, web запросы, чтение файлов)

Конструкция using нужна нам, чтобы удалять **неуправляемые** ресурсы. Например, перед завершением метода закрыть подключение к бд.

```c#
public List<Person> GetAll() {
	using(DatabaseContext context = new DatabaseContext) {
		return context.Person.ToList();
        //как только выполнение метода перейдет скобку ниже, то вызовется метод Dispose() у context, и подключение к бд закроется
    }    
}

```

**Как понять, где нужен using, а где нет?**

Если открыть реализацию класса, и он будет реализовывать интерфейс IDisposable, то использование объекта этого класса нужно обернуть в using

### Асинхронность

Статья https://metanit.com/sharp/tutorial/13.3.php

Асинхронность позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы или блоки кода. Это несет выгоды в веб-приложениях при обработке запросов от пользователей, при обращении к базам данных или сетевым ресурсам. При больших запросах к базе данных асинхронный метод просто уснет на время, пока не получит данные от БД, а основной поток сможет продолжить свою работу. В синхронном же приложении, если бы код получения данных находился в основном потоке, этот поток просто бы блокировался на время получения данных.

Здесь мы рассмотрим, как переписать синхронный метод на асинхронный при обращении к базе данных.
Этот алгоритм сработает при обращении к любому асинхронному методу.

```c#
public List<Person> GetAll() {
	using (DbContext context = new DbContext()) {
        var result = context.Person.Where(x => x.Status != 0); //тут не обращаемся к базе, т.к. ленивые вычилсления
        
        return context.Person.ToList(); //1.найти место обращения к бд
    }
}

//новый вариант метода
public async Task<List<Person>> GetAll() {
    //4.дописать async
    //5.изменить тип возвращаемого значения List<Person> на Task<List<Person>>.
    // если было void, то нужно переписать на Task, так как возвращать void из асинхронных методов плохая практика
    
    using (DbContext context = new DbContext()) {
        var result = context.Person.Where(x => x.Status != 0); 
        //2.найти место обращения к бд, переделать ToList на ToListAsync
        //3.добавить await
        return await context.Person.ToListAsync(); 
    }
}
```

Это нам позволит дать возможность потоку работать в своем темпе и не тратить лишнее время на ожидание ответа с базы данных.

Основное правило: хочешь написать await ? пиши async и переписывай возвращаемое значение на Task<>

### Основные принципы объектно-ориентированного программирования

Статья: https://tproger.ru/translations/oop-principles-cheatsheet/

Когда мы создаем классы, у нас есть 5 инструментов и 5 принципов, помогающих сделать это правильно

Инструменты (их могут называть столпы ООП, принципы ООП, по разному в зависимости от книги)

* Абстракция - выделение только значимых вещей для класса и игнорирование необязательных
* Инкапсуляция - механизм связывания состояния класса с его поведением
* Наследование - способность класса передавать свою функциональность классу-наследнику
* Полиморфизм - реализация одной и той же идеи разными способами ( например virtual и override методы, или обобщения)
* Композиция - механизм, когда поведение класса реализуется через его поля - объекты

Принципы (SOLID)

* S - принцип единой ответственности : класс должен отвечать лишь за свой участок логики
* O - принцип открытости/закрытости : класс должен быть закрыт для внешнего изменения, но открыт для модификации
* L - принцип подстановки Барбары Лисков: методы, использующие базовый тип, должны иметь возможность использовать дочерний без потери функциональности
* I - принцип разделения интерфейсов: интерфейсы должны быть разделены на более мелкие, нежели быть одним большим и универсальным
* D - принцип инверсии зависимостей: зависимости в коде должны быть лишь на абстракции, а не на их реализации

## Как работает .NET и C#

## Создание сервера при помощи ASP NET

