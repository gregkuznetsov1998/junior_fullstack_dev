Основные вопросы по backend части приложений, в частности c#

# C#

## Базовые конструкции

### Переменные

Статья: https://metanit.com/sharp/tutorial/2.25.php
В программировании в целом **переменные** нужны для хранения временных данных. Она представляет собой область данных в памяти, в которой хранится значение определенного типа. 
Переменная имеет 3 параметра: 

* Тип (string, bool, float, int, char...)
* Имя (должно быть одной строкой без пробелов, чувствительно к регистру)
* Значение

Как задать переменную: 

```c#
//тип_данных название
string name;

//присвоение значения
name = "test";
```

Все типы данных, которые есть в c#, тут https://metanit.com/sharp/tutorial/2.1.php

Если не присваивать переменной значение, то она примет значение default, уникальное для своего типа

```c#
object obj; //будет null
int num; //будет 0
string str; //будет null
bool boo; //будет false
```

### Преобразования типов данных
Статья: https://metanit.com/sharp/tutorial/2.2.php

```c#
//можно конвертить базовые типы явно
int test = 5;
long newTest = (long)test;

//но лучше это делать через Convert
string test = "5";
int newTest = Convert.ToInt32(test);


```

### Условия

Статья: https://metanit.com/sharp/tutorial/2.24.php, https://metanit.com/sharp/tutorial/2.5.php

Работают на основе bool, в языке используются конструкции: if..else и switch..case

```c#
//можно сначала расчитать переменную, потом передать ее в if, либо сразу написать условие
bool condit = 5 > 2;

if(condit) {
    //если true
}
else {
   	//если false
}
//альтернатива
if(5 > 2) {
    //если true
}
else {
   	//если false
}
```

Если надо много условий, то варианта 2: либо логические операции, либо else if

```c#
int a = 5;
//если условия можно проверить последовательно
if(a > 0) {
    
}
else if(a > 3) {
    
}
//сколько угодно раз

//если условия надо проверить одновременно
//&& -> true && false = false (логическое умножение)
//|| -> true || false = true (логическое сложение)
if(a>0&& a < 5 || a > 100) {
    //если true
}
else {
    //если false
}
```

### Циклы

Статья: https://metanit.com/sharp/tutorial/2.6.php
Виды циклов и их разница: 

```c#
//если надо посчитать определенное количество раз и ты точно знаешь сколько:
//три параметра: начальное значение, условие работы, как счетчик будет изменяться
//тут цикл будет идти от 0 до 8, увеличиваясь каждый раз
for (int i = 0; i < 9; i++)
{
    Console.WriteLine($"Квадрат числа {i} равен {i*i}");
}

//если ты не знаешь точно, сколько итераций тебе надо:
//while и do while будут работать, пока верно условие в скобках while
//разница лишь в том, что do while всегда сделает первую итерацию, обычный while этого делать не должен
int i = 6;
do
{
    Console.WriteLine(i);
    i--;
}
while (i > 0);
//
int i = 6;
while (i > 0)
{
    Console.WriteLine(i);
    i--;
}

//если надо перебрать коллекцию(массив), то foreach
var mass = new List<int>();
foreach(var elem in mass) {
    //elem это каждый элемент массива по очереди
}
```

Есть ключевые слова, которые могут остановить цикл или пропустить одну итерацию

```c#
var mass = new List<int>();
foreach(var elem in mass) {
    continue; // пропустит итерацию в цикле, продолжит работать со следующей
    break; //остановит цикл впринципе
}
```

### Массивы и коллекции

Статьи: https://metanit.com/sharp/tutorial/2.4.php, https://metanit.com/sharp/tutorial/4.3.php

Массив представляет набор однотипных данных. Есть несколько видов коллекций, которые различаются по алгоритму взаимодействия с данными. Самых ходовых две: 

```c#
//Обычный массив
//имеет ограниченное количество элементов
int[] array = new int[5] {1,2,3,4,5};
//получение элемента
int elem = array[0];

//Динамический список, может расширять количество элементов при помощи нескольких методов
List<int> array = new List<int>() {1,2,3,4,5};
//получение элемента такое же
int elem = array[0];
//добавить элемент в коллекцию
array.Add(6);
//удалить элемент из коллекции
array.Remove(1);
```

### Перечисления enum

Статья: https://metanit.com/sharp/tutorial/2.12.php

Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора **enum**. Если значения для констант не указывать, то расчет начнется с 0

```c#
enum Operation
{ 
    Add = 1,   // каждый следующий элемент по умолчанию увеличивается на единицу
    Subtract, // этот элемент равен 2
    Multiply, // равен 3
    Divide    // равен 4
}

//переменная типа Enum
Operation test = Operation.Add;
```

## Классы и немного ООП

### Что такое классы и их объекты

Статья: https://metanit.com/sharp/tutorial/3.1.php (и дальше по главе)

В c# принято представлять программу в виде взаимодействия объектов между собой

Описанием объекта является **класс**, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. То есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.

```c#
// создание класса
public class MyClass {
    //...
}
//создание объекта класса
MyClass obj = new MyClass();
```

Через объект класса мы можем взаимодействовать с его **состоянием** и **поведением**

### Описание класса 

Класс создается ключевым словом **class** и может содержать в себе 4 характеристиками : поля и свойства (**состояние**), конструкторы и методы (**поведение**).

**Поля** - просто переменные, содержащие состояние объекта класса

```c#
public class MyClass {
    public int field; //поле класса MyClass
}
```

**Свойства** - те же поля, но имеют правила доступа к данным (аксессоры)

```c#
public class MyClass {
    public int Field {get; set} //свойство класса MyClass
}
```

**Методы** - это выделенные блоки кода, которые выполняют определенные действия. Методы описывают **поведение** класса. В возвращаемом значении указывается либо void (если ничего не нужно возвращать из метода, **return** не обязателен), либо тип данных, который должен вернуться по завершению метода(**return** обязателен)

```c#
public class MyClass {
    public void Print() { //метод класса MyClass, который ничего не возвращает
        Console.WriteLine("test");
    } 
    public int Print() { //метод класса MyClass, который должен вернуть число
        Console.WriteLine("test");
        return 0;
    } 
}
```

**Конструкторы** - методы, которые используются для создания объекта, называются так же как класс и **не имеют** возвращаемого значения. Вызываются ключевым словом **new**

```c#
public class MyClass {
    //конструктор по умолчанию класса MyClass
    public MyClass() {
        
    } 
    //обычный конструктор класса MyClass
    public MyClass(int a) {
        
    } 
}

MyClass obj = new MyClass(); //сработает конструктор по умолчанию
MyClass obj1 = new MyClass(5); //сработает обычный конструктор 
```

### Модификаторы доступа 

Статья: https://metanit.com/sharp/tutorial/3.2.php

В C# применяются следующие модификаторы доступа:

Основные: 

* **public**: публичный, видно везде. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
* **private**: приватный, видно только внутри класса или контекста. Представляет полную противоположность модификатору public. 
* **protected**:  видно только внутри самого класса, и его дочерних классах. При этом производные классы могут располагаться в других сборках.
* **internal**: почти как public, но видно только в текущей программе(сборке)

Дополнительные: 

* **protected internal**: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
* **private protected**: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.

### Наследование

Статья: https://metanit.com/sharp/tutorial/3.7.php

Наследование нужно, чтобы передать функционал базового класса дочернему. Передадутся все свойства и методы, которые помечены модификатором **protected** и **public** 

```c#
public class Person {
    private bool foo; // не перейдет в дочерний
    public int Field {get; set;} // перейдет в дочерний
    protected void Method() { // перейдет в дочерний
        
    }
}
public class Employee : Person {
    //будет содержать свойство Field и метод Method
}

// при использовании объекта можно создавать объекты так:
Person obj = new Employee();
```

Про ковариантность можно почитать тут: https://metanit.com/sharp/tutorial/3.27.php

### Абстрактные, статические  классы и виртуальные методы

У классов и методов могут быть модификаторы, такие как **abstract** и **static**
Оба типа классов не могут иметь объектов, но взаимодействие с их содержимым различается. Абстрактные классы требуют наследования, и взаимодействовать с ними возможно только через объект дочернего класса

```c#
public abstract class BasicClass {
    public void Test() {
		//...        
    }
}
public class ChildClass : BasicClass {
    
}

ChildClass obj = new ChildClass();
obj.Test(); //вызов метода абстрактного класса

BasicClass obj1 = new BasicClass(); // нельзя!
```

Методы статического класса можно вызвать только от самого класса, не вызывая его объекта

```c#
public static class BasicClass {
    public static void Test() {
		//...        
    }
}
BasicClass obj1 = new BasicClass(); // нельзя!
BasicClass.Test(); //вызов статического метода
```

Так же абстрактные и виртуальные методы можно переопределить при помощи ключевого слова **override**. Отличие абстрактного лишь в том, что он требует переопределение, а виртуальный лишь предоставляет возможность

```c#
public abstract class BasicClass {
    public abstract void Test() {
		//...        
    }
    public virtual void Meth() {
        
    }
}
public class ChildClass : BasicClass {
    public override void Test() { //обязательно
		//...        
    }
    public override void Meth() { // при неоходимости
        
    }
}
```

### Интерфейсы

Статья: https://metanit.com/sharp/tutorial/3.9.php

Интерфейсы используются для определения поведения класса без его конечной реализации и требуют от класса выполнения созданных ограничений. Пишется как обычное наследование

```c#
public interface IInter {
    void Test();
}

public class ChildInter : IInter {
    public void Test() { //обязательно
        
    }
}

// при использовании интерфейса можно делать вот так:
IInter obj = new ChildInter();
//Объект интерфейса нельзя создать:
IInter obj = new IInter(); //не будет работать
```

### Основные принципы объектно-ориентированного программирования

Статья: https://tproger.ru/translations/oop-principles-cheatsheet/

Когда мы создаем классы, у нас есть 5 инструментов и 5 принципов, помогающих сделать это правильно

Инструменты (их могут называть столпы ООП, принципы ООП, по разному в зависимости от книги)

* Абстракция - выделение только значимых вещей для класса и игнорирование необязательных
* Инкапсуляция - механизм связывания состояния класса с его поведением
* Наследование - способность класса передавать свою функциональность классу-наследнику
* Полиморфизм - реализация одной и той же идеи разными способами ( например virtual и override методы, или обобщения)
* Композиция - механизм, когда поведение класса реализуется через его поля - объекты

Принципы (SOLID)

* S - принцип единой ответственности : класс должен отвечать лишь за свой участок логики
* O - принцип открытости/закрытости : класс должен быть закрыт для внешнего изменения, но открыт для модификации
* L - принцип подстановки Барбары Лисков: методы, использующие базовый тип, должны иметь возможность использовать дочерний без потери функциональности
* I - принцип разделения интерфейсов: интерфейсы должны быть разделены на более мелкие, нежели быть одним большим и универсальным
* D - принцип инверсии зависимостей: зависимости в коде должны быть лишь на абстракции, а не на их реализации

